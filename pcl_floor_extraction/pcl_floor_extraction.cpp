/*
Extract and find floor plane with similar orientation to a given reference vector using RANSAC and get it's normal vector
2021.3.2
Written by Ahn, Jeeho
MIT license
*/

#include <iostream>
#include <pcl/ModelCoefficients.h>
#include <pcl/io/pcd_io.h>
#include <pcl/io/ply_io.h>
#include <pcl/point_types.h>
#include <pcl/sample_consensus/method_types.h>
#include <pcl/sample_consensus/model_types.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/filters/uniform_sampling.h>

#include <Eigen/Dense>

#include <memory>
#include <chrono>


typedef pcl::PointXYZ pclType;
typedef pcl::PointCloud<pclType> pclCloud;

typedef Eigen::Vector3f EV3;
typedef std::shared_ptr<EV3> EV3_ptr;

const float dot_thres = 0.97;
bool save_pcd = false;

class segmented_set
{
public:
    pclCloud::Ptr inliers;
    pclCloud::Ptr outliers;
    pcl::ModelCoefficients::Ptr surf_coeff;

    segmented_set()
    {
        inliers = nullptr;
        outliers = nullptr;
        surf_coeff = nullptr;
    }

    segmented_set(pclCloud::Ptr inl, pclCloud::Ptr outl, pcl::ModelCoefficients::Ptr coeff)
    {
        inliers = inl;
        outliers = outl;
        surf_coeff = coeff;
    }
    EV3_ptr surf_normal()
    {
        return std::make_shared<EV3>(EV3(surf_coeff->values[0], surf_coeff->values[1], surf_coeff->values[2]));
    }
};

pclCloud::Ptr uniform_filter(pclCloud::Ptr cloud_in)
{
    pclCloud::Ptr cloud_filtered(new pclCloud);
    pcl::UniformSampling<pclType> us(true); // extract removed indices
    us.setInputCloud(cloud_in);
    us.setRadiusSearch(0.03);
    us.filter(*cloud_filtered);

    pcl::PointIndices removed_indices;
    // These are "fake" indices generated by initCompute(), already sorted
    auto input_indices = us.getIndices();
    // Removed indices, not guaranteed to be sorted
    us.getRemovedIndices(removed_indices);
    //std::sort(removed_indices.indices.begin(), removed_indices.indices.end());
    // Compute retained indices as a set difference between all and removed
    pcl::Indices retained;
    std::set_difference(input_indices->begin(), input_indices->end(), removed_indices.indices.begin(), removed_indices.indices.end(),
        std::inserter(retained, retained.begin()));
    pcl::copyPointCloud(*cloud_in, retained, *cloud_filtered);

    return cloud_filtered;
}

template<typename T>
std::shared_ptr<T> load_pcd_file(std::string fname)
{
    std::cout << "Loading PointCloud File: " << fname << std::endl;
    std::shared_ptr<T> out_cloud(new pclCloud);
    std::string last_three = fname.substr(fname.size() - 3, 3);

    if (last_three == "pcd")
    {
        if (pcl::io::loadPCDFile(fname, *out_cloud) == -1)
        {
            PCL_ERROR(std::string("Failed to load PCD File " + fname + "\n").c_str());
            exit(-2);
        }
        return out_cloud;
    }
    else if (last_three == "ply")
    {
        if (pcl::io::loadPLYFile(fname, *out_cloud) == -1)
        {
            PCL_ERROR(std::string("Failed to load PLY File " + fname + "\n").c_str());
            exit(-2);
        }
        return out_cloud;
    }
    else
    {
        PCL_ERROR(("Unknown extension: " + last_three).c_str());
        exit(-2);
    }
}

pcl::SACSegmentation<pclType> init_plane_seg(double distance_thres)
{
    // Create the segmentation object
    pcl::SACSegmentation<pclType> seg;
    // Optional
    seg.setOptimizeCoefficients(true);
    // Mandatory
    seg.setModelType(pcl::SACMODEL_PLANE);
    seg.setMethodType(pcl::SAC_RANSAC);
    seg.setMaxIterations(50);
    seg.setNumberOfThreads(0);
    seg.setDistanceThreshold(distance_thres);

    return seg;
}

segmented_set segment_single_plane(pclCloud::Ptr cloud, double dist_thres)
{
    auto seg = init_plane_seg(dist_thres); //0.01
    pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients);
    pcl::PointIndices::Ptr inliers(new pcl::PointIndices);

    seg.setInputCloud(cloud);
    seg.segment(*inliers, *coefficients);

    if (inliers->indices.size() == 0)
    {
        PCL_ERROR("Could not estimate a planar model for the given dataset.");
        return (segmented_set()); //filled with nullptr
    }

    /*
    std::cerr << "Model coefficients: " << coefficients->values[0] << " "
        << coefficients->values[1] << " "
        << coefficients->values[2] << " "
        << coefficients->values[3] << std::endl;
        */

    pclCloud::Ptr out_cloud_inlier(new pclCloud);
    pclCloud::Ptr out_cloud_outlier(new pclCloud);
    // Create the filtering object
    pcl::ExtractIndices<pclType> extract;
    // Extract the inliers
    extract.setInputCloud(cloud);
    extract.setIndices(inliers);
    extract.setNegative(false);
    extract.filter(*out_cloud_inlier);

    extract.setNegative(true);
    extract.filter(*out_cloud_outlier);

    return segmented_set(out_cloud_inlier, out_cloud_outlier, coefficients);

    /*
    pclCloud::Ptr out_cloud_inlier(new pclCloud);
    out_cloud_inlier->resize(inliers->indices.size());
    for (size_t i = 0; i < inliers->indices.size(); ++i)
    {
        pclType temp(cloud->points[inliers->indices[i]].x, cloud->points[inliers->indices[i]].y, cloud->points[inliers->indices[i]].z);
        out_cloud_inlier->at(i) = temp;
    }

    pclCloud::Ptr out_cloud_inlier(new pclCloud);
    out_cloud_inlier->resize(inliers->indices.size());
    for (size_t i = 0; i < inliers->indices.size(); ++i)
    {
        pclType temp(cloud->points[inliers->indices[i]].x, cloud->points[inliers->indices[i]].y, cloud->points[inliers->indices[i]].z);
        out_cloud_inlier->at(i) = temp;
    }
    */
}

std::pair<pclCloud::Ptr, EV3_ptr> extract_floor(pclCloud::Ptr cloud)
{
    std::vector<segmented_set> segmented_list;

    bool finished = false;
    pclCloud::Ptr pivot_cloud = cloud;

    //set max. num. of points left to repeat
    auto size_thres = cloud->size() / 4;

    auto time_start = std::chrono::system_clock::now();
    while (finished == false)
    {
        auto segmented_clouds = segment_single_plane(pivot_cloud, 0.01);
        if (segmented_clouds.outliers->size() < size_thres)
        {
            std::cout << "Cloud Size thres reached. Terminate RANSAC" << std::endl;
            //save last plane to list
            segmented_list.push_back(segmented_clouds);
            //stop loop
            break;
        }
        if (segmented_clouds.inliers == nullptr)
        {
            std::cout << "No more Plane found" << std::endl;
            finished = true;
        }
        else
        {
            //save inlier to list
            segmented_list.push_back(segmented_clouds);
            //reiterate with leftover
            pivot_cloud = segmented_clouds.outliers;
        }
    }

    std::cout << "Time Counted: " << std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - time_start).count() << std::endl;
    //auto ref_vec = Eigen::Vector3f(0, 0.866, 0.5);
    auto ref_vec = Eigen::Vector3f(0, 0, 1);
    std::vector<segmented_set> floor_angle_planes;
    if (segmented_list.size() == 0)
    {
        std::cout << "No Plane Found from the source cloud" << std::endl;
        return std::make_pair(nullptr,nullptr);
    }
    else
    {
        std::cout << "Planes Found: " << segmented_list.size() << std::endl;
        for (int n = 0; n < segmented_list.size(); n++)
        {
            if(save_pcd)
                pcl::io::savePCDFile("plane" + std::to_string(n) + ".pcd", *segmented_list[n].inliers);
            //std::cout << "Surface Normal: " << *(segmented_list[n].surf_normal()) << std::endl;
            float dot = ref_vec.dot(*(segmented_list[n].surf_normal()));
            std::cout << "dot: " << dot << std::endl;
            if (fabs(dot) > dot_thres)
                floor_angle_planes.push_back(segmented_list[n]);
        }

        if (floor_angle_planes.size() == 0)
        {
            std::cout << "No Floor Plane Found from the source cloud" << std::endl;
            return std::make_pair(nullptr, nullptr);
        }
        else if (floor_angle_planes.size() == 1)
        {
            std::cout << "Unique Floor normal:\n" << *floor_angle_planes[0].surf_normal() << std::endl;
            return std::make_pair(floor_angle_planes[0].inliers,floor_angle_planes[0].surf_normal());
        }
        else //multiple planes with similar angles found
        {
            //choose one with most number of points
            auto pivot = floor_angle_planes[0];
            for (int n = 1; n < floor_angle_planes.size(); n++)
            {
                if (floor_angle_planes[n].inliers->size() > pivot.inliers->size())
                    pivot = floor_angle_planes[n];
            }

            std::cout << "Best Floor normal:\n" << *pivot.surf_normal() << std::endl;
            return std::make_pair(pivot.inliers, pivot.surf_normal());
        }
    }
}

int main()
{
    //auto cloud = load_pcd_file<pclCloud>("rs_floor.ply");
    auto cloud = load_pcd_file<pclCloud>("depth_img_test.pcd");
    auto time_start_f = std::chrono::system_clock::now();
    cloud = uniform_filter(cloud);
    auto time_fin_f = std::chrono::system_clock::now();
    std::cout << "Sampling Time Counted: " << std::chrono::duration_cast<std::chrono::milliseconds>(time_fin_f - time_start_f).count() << std::endl;

    
}
